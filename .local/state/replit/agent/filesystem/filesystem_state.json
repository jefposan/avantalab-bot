{"file_contents":{"telegram_bot.py":{"content":"import csv\nimport os\nimport re\nfrom datetime import datetime\nfrom telegram import Update\nfrom telegram.ext import Updater, MessageHandler, CommandHandler, Filters, CallbackContext\n\n# === CONFIGURA√á√ïES ===\nTOKEN = os.environ.get(\"TELEGRAM_TOKEN\")\nCSV_FILE = \"dados.csv\"\n\n\n# === CRIA√á√ÉO E GRAVA√á√ÉO DO CSV ===\ndef ensure_csv():\n    \"\"\"Cria o CSV com cabe√ßalho completo (compat√≠vel com Excel).\"\"\"\n    if not os.path.exists(CSV_FILE):\n        with open(CSV_FILE, \"w\", newline=\"\", encoding=\"utf-8-sig\") as f:\n            writer = csv.writer(f, delimiter=\",\")\n            header = [\n                \"timestamp_utc\", \"user_id\", \"username\", \"nome_apostador\", \"d1\",\n                \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\", \"d10\"\n            ]\n            writer.writerow(header)\n\n\ndef salvar_csv(user_id: int, username: str, nome_apostador: str,\n               dezenas_fmt: str):\n    \"\"\"Salva nome + 10 dezenas em colunas separadas.\"\"\"\n    ensure_csv()\n\n    # Extrai as dezenas e garante 10 valores\n    numeros = re.findall(r\"\\d{1,2}\", dezenas_fmt)\n    dezenas = [int(n) for n in numeros if 1 <= int(n) <= 60][:10]\n    dezenas.sort()\n    while len(dezenas) < 10:\n        dezenas.append(\"\")\n\n    dezenas_str = [\n        f\"{d:02d}\" if isinstance(d, int) and d != \"\" else \"\" for d in dezenas\n    ]\n\n    row = [datetime.utcnow().isoformat(), user_id, username, nome_apostador\n           ] + dezenas_str\n\n    with open(CSV_FILE, \"a\", newline=\"\", encoding=\"utf-8-sig\") as f:\n        writer = csv.writer(f, delimiter=\",\")\n        writer.writerow(row)\n\n\n# === TRATAMENTO DAS DEZENAS ===\ndef extrair_dezenas(texto: str):\n    nums = re.findall(r\"\\d{1,2}\", texto)\n    dezenas = [int(n) for n in nums if 1 <= int(n) <= 60]\n    return dezenas\n\n\ndef validar_dezenas(raw_text: str):\n    dezenas = extrair_dezenas(raw_text)\n\n    if len(dezenas) != 10:\n        return False, \"Voc√™ deve informar **exatamente 10** dezenas (ex.: 1 6 12 23 30 34 41 45 52 60).\"\n\n    if len(set(dezenas)) != 10:\n        return False, \"N√£o repita dezenas. Envie 10 n√∫meros diferentes.\"\n\n    dezenas_ordenadas = sorted(dezenas)\n    return True, dezenas_ordenadas\n\n\ndef fmt(dezenas_int):\n    return \", \".join(f\"{d:02d}\" for d in dezenas_int)\n\n\n# === MENSAGENS PADR√ÉO ===\nWELCOME = (\"üéüÔ∏è Seja bem-vindo!\\n\"\n           \"Por favor, envie **10 dezenas** de 01 a 60 separadas por espa√ßo \"\n           \"(ex.: 1 6 12 23 30 34 41 45 52 60).\")\n\n\ndef pedir_dezenas(update: Update):\n    update.message.reply_text(WELCOME)\n\n\n# === FLUXO DO BOT ===\ndef start(update: Update, context: CallbackContext):\n    context.user_data.clear()\n    context.user_data[\"fase\"] = \"aguardando_dezenas\"\n    pedir_dezenas(update)\n\n\ndef handle_text(update: Update, context: CallbackContext):\n    user = update.message.from_user\n    username = user.username or user.first_name or str(user.id)\n    text = update.message.text.strip()\n    fase = context.user_data.get(\"fase\")\n\n    # 1Ô∏è‚É£ in√≠cio ou rein√≠cio\n    if fase is None or fase == \"finalizado\":\n        context.user_data[\"fase\"] = \"aguardando_dezenas\"\n        pedir_dezenas(update)\n        return\n\n    # 2Ô∏è‚É£ aguardando dezenas\n    if fase == \"aguardando_dezenas\":\n        ok, resultado = validar_dezenas(text)\n        if not ok:\n            update.message.reply_text(f\"‚ö†Ô∏è {resultado}\")\n            return\n\n        dezenas_fmt = fmt(resultado)\n        context.user_data[\"dezenas_fmt\"] = dezenas_fmt\n        update.message.reply_text(\n            f\"Aposta registrada com sucesso! ‚úÖ\\n\"\n            f\"Suas dezenas em ordem crescente: {dezenas_fmt}\\n\\n\"\n            f\"Agora, por favor, envie o **nome do apostador** para seguirmos para o pagamento.\"\n        )\n        context.user_data[\"fase\"] = \"aguardando_nome\"\n        return\n\n    # 3Ô∏è‚É£ aguardando nome do apostador\n    if fase == \"aguardando_nome\":\n        nome_apostador = text.strip().title()\n        dezenas_fmt = context.user_data.get(\"dezenas_fmt\", \"\")\n        salvar_csv(user.id, username, nome_apostador, dezenas_fmt)\n        update.message.reply_text(f\"‚úÖ Aposta finalizada com sucesso!\\n\"\n                                  f\"Nome do apostador: {nome_apostador}\\n\"\n                                  f\"Dezenas: {dezenas_fmt}\\n\\n\"\n                                  f\"Boa sorte! üçÄ\")\n        context.user_data[\"fase\"] = \"finalizado\"\n        context.user_data.pop(\"dezenas_fmt\", None)\n        return\n\n    # 4Ô∏è‚É£ fallback\n    context.user_data[\"fase\"] = \"aguardando_dezenas\"\n    pedir_dezenas(update)\n\n\n# === EXECU√á√ÉO DO BOT ===\ndef main():\n    ensure_csv()\n    updater = Updater(TOKEN, use_context=True)\n    dp = updater.dispatcher\n\n    dp.add_handler(CommandHandler(\"start\", start))\n    dp.add_handler(MessageHandler(Filters.regex(r\"(?i)^\\s*come√ßar\\s*$\"),\n                                  start))\n    dp.add_handler(MessageHandler(Filters.text & ~Filters.command,\n                                  handle_text))\n\n    updater.start_polling()\n    updater.idle()\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":4975},"replit.md":{"content":"# Avantalab Bot\n\n## Overview\nThis is a Python Telegram bot that logs all incoming messages to a CSV file. The bot listens for text messages and commands, recording the timestamp, user ID, username, and message content.\n\n## Project Structure\n- `telegram_bot.py` - Main bot application\n- `dados.csv` - CSV file storing message logs\n- `requirements.txt` - Python dependencies\n\n## Recent Changes\n- **2025-11-05**: Initial Replit setup\n  - Installed Python 3.11 and dependencies\n  - Configured TELEGRAM_TOKEN secret\n  - Set up workflow to run the bot\n  - Added .gitignore for Python projects\n  - Created documentation\n\n## Dependencies\n- `python-telegram-bot==13.15` - Telegram bot framework\n\n## Environment Variables\n- `TELEGRAM_TOKEN` - Required. Bot token from @BotFather on Telegram\n\n## How It Works\n1. The bot connects to Telegram using the provided token\n2. It listens for all text messages and commands\n3. Each message is logged to `dados.csv` with:\n   - Timestamp (UTC)\n   - User ID\n   - Username (or full name if username not set)\n   - Message text\n\n## Running the Bot\nThe bot runs automatically via the `telegram-bot` workflow. It uses polling to receive updates from Telegram.\n\n## Important Notes\n- Only one instance of the bot can run at a time with the same token\n- If you see a \"Conflict\" error, make sure no other instances are running elsewhere\n- The CSV file grows over time - consider periodic backups or cleanup\n- The bot logs all messages it receives, so ensure proper data privacy practices\n\n## Deployment\nThis bot is configured to run as a VM deployment since it needs to maintain a persistent connection to Telegram's servers.\n","size_bytes":1644},"README.md":{"content":"# avantalab-bot","size_bytes":15},"server.py":{"content":"from flask import Flask, send_file\nimport os\n\napp = Flask(__name__)\n\n\n@app.route('/')\ndef home():\n    return '<h3>‚úÖ Servidor rodando. Acesse /dados.csv para visualizar o arquivo.</h3>'\n\n\n@app.route('/dados.csv')\ndef baixar_csv():\n    caminho = \"dados.csv\"\n    if os.path.exists(caminho):\n        return send_file(caminho, mimetype=\"text/csv\", as_attachment=False)\n    else:\n        return \"Arquivo n√£o encontrado.\", 404\n\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8080)\n","size_bytes":491}},"version":2}